<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".c" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    // Reuse the same model shape used elsewhere: { Device: string, Config: IDictionary<string,string> }
    dynamic model = (Session != null && Session.ContainsKey("config")) ? Session["config"] : null;
    IDictionary<string, string> cfg = null;
    try { if (model != null && model.Config != null) cfg = (IDictionary<string, string>)model.Config; } catch { }

    string Val(string key, string defVal)
    {
        if (cfg != null && cfg.TryGetValue(key, out var v) && !string.IsNullOrWhiteSpace(v)) return v;
        return defVal;
    }

    // Use same defaults as your system init
    var prefEn = Val("PREFEN", "3");
    var pfmWs  = Val("PFMWS",  "3");
    var eccCon = Val("ECCCON", "3");
#>
// *****************************************************************************
// *****************************************************************************
// File: plib_clk.c
// Summary: Clock PLIB implementation generated by T4
// *****************************************************************************
// *****************************************************************************

#include "plib_clk.h"

// If your toolchain requires device headers, include them here (e.g., <xc.h> or "device.h")
// #include <xc.h>
// #include "device.h"

void CLK_Initialize(void)
{
    // Configure prefetch and wait states
    PRECONbits.PREFEN = <#= prefEn #>;
    PRECONbits.PFMWS  = <#= pfmWs #>;

    // Configure ECC behavior if available on the device
    CFGCONbits.ECCCON = <#= eccCon #>;

    // TODO: Add more clock tree setup here if needed (SPLL, POSC, FRCDIV, etc.)
    // This template reads values from ProjectSettings.json via the shared Session model
}